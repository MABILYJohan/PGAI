<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>RRaffin - Visualisation de Maillages - AMU/LIS 7020</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #808080;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="info">Afficheur de maillage 3D</div>

		<script src="js/three.min.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
		<script src="js/loaders/PLYLoader.js"></script>

		<script src="js/loaders/ctm/lzma.js"></script>
		<script src="js/loaders/ctm/ctm.js"></script>
		<script src="js/loaders/ctm/CTMLoader.js"></script>

		<script>

			//Vérification des possibilités WebGL
			//if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
			var camera, scene, renderer;
			var meshPLY;
			var mouse = new THREE.Vector2();
			var raycaster = new THREE.Raycaster();
			
			var myPoints = [];
			var myBool = false;

			//theShadowLight;
			//var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

				//Lancement du rendu
				init();
				animate();

			function init() {

				container = document.getElementById( 'container' );

				var canvas = document.createElement( 'canvas' );
					canvas.width = 128;
					canvas.height = 128;

				var context = canvas.getContext( '2d' );
				context.fillRect( 0, 0, canvas.width, canvas.height );

				var lightBox = 10.0;


				renderer = new THREE.WebGLRenderer( { antialias: true} );
					renderer.setClearColor( 0xffffff );
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );

									//Caméra
				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 10000 );
					camera.position.z = lightBox;
					cameraTarget = new THREE.Vector3( 0, 0, 0 );

				//Contrôles
				controls = new THREE.TrackballControls( camera );
					controls.rotateSpeed = 5.0;
					controls.zoomSpeed = 1;
					controls.panSpeed =1;

					controls.noZoom = false;
					controls.noPan = false;

					controls.staticMoving = true;
					controls.dynamicDampingFactor = 0.3;

				//Création de la scène
				scene = new THREE.Scene();

				//Mise en place d'une lumière ambiente
				scene.add( new THREE.AmbientLight( 0xffffff ) );
				var myLightPos = new THREE.Vector3( 0, 0, 0 );


					//fichier source du maillage, SUZANNE.PLY, loader ply
					var sourcePLY = 'data/suzanne.ply'
					//console.log("viewMesh Ply : "+sourcePLY);

					var loaderPLY = new THREE.PLYLoader();

					loaderPLY.load(sourcePLY, function ( geometryPLY ) {

						geometryPLY.computeFaceNormals();
							geometryPLY.computeVertexNormals();
							geometryPLY.computeBoundingBox();

						var centrePLY = new THREE.Vector3();
							centrePLY.x = ( geometryPLY.boundingBox.max.x + geometryPLY.boundingBox.min.x ) / 2.0;
							centrePLY.y = ( geometryPLY.boundingBox.max.y + geometryPLY.boundingBox.min.y ) / 2.0;
							centrePLY.z = ( geometryPLY.boundingBox.max.z + geometryPLY.boundingBox.min.z ) / 2.0;

						geometryPLY.computeBoundingSphere();

						var materialPLY = new THREE.MeshLambertMaterial({
							color: 0x443322, 
						    wireframe: true
						} );

						meshPLY = new THREE.Mesh( geometryPLY, materialPLY );
							meshPLY.position.set( -centrePLY.x, -centrePLY.y, -centrePLY.z);
							meshPLY.castShadow = true;
							meshPLY.receiveShadow = true;

						myLightPos.x = 1.1*geometryPLY.boundingBox.max.x;
						myLightPos.y = 1.1*geometryPLY.boundingBox.max.y;
						myLightPos.z = 1.1*geometryPLY.boundingBox.max.z;

						scene.add( meshPLY );
					});

					//fichier source du maillage, STATUES.CTM, loader ctm
					/*var sourceCTM = 'data/statues.ctm'
					console.log("viewMesh CTM : "+sourceCTM);

					var loaderCTM = new THREE.CTMLoader();

					loaderCTM.load(sourceCTM, function ( geometryCTM ) {

						geometryCTM.computeFaceNormals();
							geometryCTM.computeVertexNormals();
							geometryCTM.computeBoundingBox();

						var centreCTM = new THREE.Vector3();
							centreCTM.x = ( geometryCTM.boundingBox.max.x + geometryCTM.boundingBox.min.x ) / 2.0;
							centreCTM.y = ( geometryCTM.boundingBox.max.y + geometryCTM.boundingBox.min.y ) / 2.0;
							centreCTM.z = ( geometryCTM.boundingBox.max.z + geometryCTM.boundingBox.min.z ) / 2.0;

						geometryCTM.computeBoundingSphere();

						var materialCTM = new THREE.MeshLambertMaterial({color: 0x443322 } );

						var meshCTM = new THREE.Mesh( geometryCTM, materialCTM );
							meshCTM.position.set( -centreCTM.x, -centreCTM.y, -centreCTM.z);
							meshCTM.castShadow = true;
							meshCTM.receiveShadow = true;

						myLightPos.x = 1.1 * geometryCTM.boundingBox.max.x;
						myLightPos.y = 1.1 * geometryCTM.boundingBox.max.y;
						myLightPos.z = 1.1 * geometryCTM.boundingBox.max.z;

						scene.add( meshCTM );
					});*/

				//une lumière supplémentaire
				var myLight = new THREE.SpotLight( 0xffffff );
					myLight.castShadow = false;            // default false
					myLight.position.set(myLightPos.x, myLightPos.y, myLightPos.z);
				scene.add( myLight );

				//gestion des ombres
					renderer.shadowMap.enabled = true;
					//renderer.shadowMap.cullFace = THREE.CullFaceFront;//deprecated in v89
					//renderer.shadowMap.renderReverseSided = true; //v89 deprecated in v97
					renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

					//un spotLight pour les ombres
					var lightShadow = new THREE.SpotLight( 0xffffff );
					lightShadow.castShadow = true;            // default false
					scene.add( lightShadow );

					//les paramètres du spotlight des ombres
					lightShadow.shadow.mapSize.width = 512;  // default (cf doc ThreeJS.org)
					lightShadow.shadow.mapSize.height = 512; // default
					lightShadow.shadow.camera.near = 0.5;       // default
					lightShadow.shadow.camera.far = 500      // default
					lightShadow.position.set(camera.position.x, camera.position.y, camera.position.z);
				
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
				container.addEventListener( 'mousemove', onMouseMove, false );
				container.addEventListener( 'click', onMouseClick, false );
			}

			function onMouseClick (event) 
			{
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				if (myBool) {
					myBool = false;
					var i;
					console.log("Tracé terminé \nPoints qui ont été stockés:");
					var material = new THREE.MeshStandardMaterial( { color : 0x00cc00 } );
					var geometry = new THREE.Geometry();
					var ptTmp;
					for(i=0; i<myPoints.length; i++)
					{
						console.log("myPoints "+ i + ":"  + myPoints[i].x 
							+ " " + myPoints[i].y + " "+ myPoints[i].z);
						if(!geometry.vertices.includes(myPoints[i])){
							geometry.vertices.push(myPoints[i]);
							ptTmp += myPoints[i];
						}


					}
					ptTmp /= geometry.vertices.length;
					geometry.vertices.push(ptTmp);
					// console.log(geometry.vertices);
					var normal = new THREE.Vector3( 0, 1, 0 ); //optional
					var color = new THREE.Color( 0xffaa00 ); //optional
					var materialIndex = 0; //optional
						
					var nbV = geometry.vertices.length;
					geometry.computeFlatVertexNormals();
					for(var j=0; j < nbV; j++){
						var face = new THREE.Face3( 
							0, 
							(j%(nbV-1))+1, 
							(j%(nbV-1))+2, 
							normal, 
							color, 
							materialIndex
						);
						geometry.faces.push( face );
					}
					scene.add( new THREE.Mesh( geometry, material ) );
				}
				else {
					myBool = true;
					myPoints = new Array(); 
					console.log("tracer le polygone");
				}
			}

			function onMouseMove( event )
			{
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObject( meshPLY );

				if ( intersects.length > 0 ) {
					var P = intersects[0].point;
					if (myBool)
					{
						// var face = intersects[0].face;
						// var material = new THREE.MeshStandardMaterial( { color : 0x00cc00 } );
						// var geometry = new THREE.Geometry();
						// console.log(intersects);
						// geometry.vertices.push(meshPLY.geometry.vertices[face.a]);
						// geometry.vertices.push(meshPLY.geometry.vertices[face.b]);
						// geometry.vertices.push(meshPLY.geometry.vertices[face.c]);
						// var normal = new THREE.Vector3( 0, 1, 0 ); //optional
						// var color = new THREE.Color( 0xffaa00 ); //optional
						// var materialIndex = 0; //optional
						// var face2 = new THREE.Face3( 0, 1, 2, normal, color, materialIndex);
						// meshPLY.geometry.faces.push( face2 );
						// scene.add( new THREE.Mesh( meshPLY.geometry, material ) );
						// console.log("vec1 : " + face.a + "vec2 : " + face.b + " vec3 : " + face.c)
						console.log("intersection : "+ P.x + " " + P.y + " "+ P.z);
						myPoints.push(P);
					}
				}
			}

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update();

				render();
			}

			function render() {

				renderer.render( scene, camera );
				
				
		
			}

		</script>
	</body>
</html>
