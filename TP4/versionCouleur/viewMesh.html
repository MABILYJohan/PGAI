<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>RRaffin - Visualisation de Maillages - AMU/LIS 7020</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #808080;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="info">Afficheur de maillage 3D</div>

		<script src="js/three.min.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
		<script src="js/loaders/PLYLoader.js"></script>

		<script src="js/loaders/ctm/lzma.js"></script>
		<script src="js/loaders/ctm/ctm.js"></script>
		<script src="js/loaders/ctm/CTMLoader.js"></script>

		<script>

			
			//Vérification des possibilités WebGL
			//if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
			var camera, scene, renderer;
			//var meshPLY;
			var mouse = new THREE.Vector2();
			var raycaster = new THREE.Raycaster();
			
			var myPoints = [];
			var myFaces = [];
			var myBool = false;

			//theShadowLight;
			//var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var meshPLY;

			//Lancement du rendu
			init();
			animate();

////////////////////////////////////////////////////////////////////////

			function init() 
			{
				container = document.getElementById( 'container' );

				var canvas = document.createElement( 'canvas' );
					canvas.width = 128;
					canvas.height = 128;

				var context = canvas.getContext( '2d' );
				context.fillRect( 0, 0, canvas.width, canvas.height );
				

				var lightBox = 10.0;

				renderer = new THREE.WebGLRenderer( { antialias: true} );
				renderer.setClearColor( 0xffffff );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				//Caméra
				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = lightBox;
				cameraTarget = new THREE.Vector3( 0, 0, 0 );

				//Contrôles
				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 5.0;
				controls.zoomSpeed = 1;
				controls.panSpeed =1;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				//Création de la scène
				scene = new THREE.Scene();

				//Mise en place d'une lumière ambiente
				scene.add( new THREE.AmbientLight( 0xffffff ) );
				var myLightPos = new THREE.Vector3( 0, 0, 0 );


				//fichier source du maillage, SUZANNE.PLY, loader ply
				//~ var sourcePLY = 'data/stanford_bunny.ply'
				var sourcePLY = 'data/suzanne.ply'
				//console.log("viewMesh Ply : "+sourcePLY);
				var loaderPLY = new THREE.PLYLoader();
				loaderPLY.load(
					sourcePLY, 
					function ( geometryPLY ) 
					{
						
						geometryPLY.computeFaceNormals();
						geometryPLY.computeVertexNormals();
						geometryPLY.computeBoundingBox();

						var centrePLY = new THREE.Vector3();
						centrePLY.x = ( geometryPLY.boundingBox.max.x + geometryPLY.boundingBox.min.x ) / 2.0;
						centrePLY.y = ( geometryPLY.boundingBox.max.y + geometryPLY.boundingBox.min.y ) / 2.0;
						centrePLY.z = ( geometryPLY.boundingBox.max.z + geometryPLY.boundingBox.min.z ) / 2.0;

						geometryPLY.computeBoundingSphere();

						// VERSION COULEUR
						//~ var materialPLY = new THREE.MeshLambertMaterial({color: 0x443322 } );
						var materialPLY = new THREE.MeshLambertMaterial({color: 0x888888, vertexColors: THREE.VertexColors});
									
						var colors = []
						var n = geometryPLY.attributes.position.count;
						for(var i = 0; i < n; i++) {
							colors.push(0, 1, 0);
						}
						var colorAttribute = new THREE.Float32BufferAttribute( colors, 3 );
						geometryPLY.addAttribute( 'color', colorAttribute );


						meshPLY = new THREE.Mesh( geometryPLY, materialPLY );
						meshPLY.position.set( -centrePLY.x, -centrePLY.y, -centrePLY.z);
						meshPLY.castShadow = true;
						meshPLY.receiveShadow = true;

						myLightPos.x = 1.1*geometryPLY.boundingBox.max.x;
						myLightPos.y = 1.1*geometryPLY.boundingBox.max.y;
						myLightPos.z = 1.1*geometryPLY.boundingBox.max.z;

						//~ if (myFaces.length > 0) 
						//~ for (var i=0; i<myFaces.length; i++)
						//~ {
							//~ console.log("hey");
							//~ meshPLY.geometry.attributes.color.setXYZ(myFaces[i].a, 1, 0, 0);
							//~ meshPLY.geometry.attributes.color.setXYZ(myFaces[i].b, 1, 0, 0);
							//~ meshPLY.geometry.attributes.color.setXYZ(myFaces[i].c, 1, 0, 0);
							//~ meshPLY.geometry.attributes.color.needsUpdate = true;
						//~ }
						//mesh = meshPLY;
						scene.add( meshPLY );
					}
				);
					
				
				// TEST
				//var geometryPLY = new THREE.Geometry();
				//~ var geometry = new THREE.ConeBufferGeometry( 20, 100, 3 );
				//~ geometry.translate( 0, 50, 0 );
				//~ geometry.rotateX( Math.PI / 2 );
				//~ helper = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial({ color: 0x00ff00, vertexColors: THREE.FaceColors }) );
				//~ scene.add( helper );
				
				
					
				//une lumière supplémentaire
				var myLight = new THREE.SpotLight( 0xffffff );
				myLight.castShadow = false;            // default false
				myLight.position.set(myLightPos.x, myLightPos.y, myLightPos.z);
				scene.add( myLight );

				//gestion des ombres
				renderer.shadowMap.enabled = true;
				//renderer.shadowMap.cullFace = THREE.CullFaceFront;//deprecated in v89
				//renderer.shadowMap.renderReverseSided = true; //v89 deprecated in v97
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

				//un spotLight pour les ombres
				var lightShadow = new THREE.SpotLight( 0xffffff );
				lightShadow.castShadow = true;            // default false
				scene.add( lightShadow );

				//les paramètres du spotlight des ombres
				lightShadow.shadow.mapSize.width = 512;  // default (cf doc ThreeJS.org)
				lightShadow.shadow.mapSize.height = 512; // default
				lightShadow.shadow.camera.near = 0.5;       // default
				lightShadow.shadow.camera.far = 500      // default
				lightShadow.position.set(camera.position.x, camera.position.y, camera.position.z);
				
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
				container.addEventListener( 'mousemove', onMouseMove, false );
				container.addEventListener( 'click', onMouseClick, false );
			}
			
////////////////////////////////////////////////////////////////////////		

			function onMouseClick (event) 
			{
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				if (myBool) 
				{
					myBool = false;
					var i;
					for (var i=0; i<myFaces.length; i++)
					{
						console.log("hey");
						meshPLY.geometry.attributes.color.setXYZ(myFaces[i].a, 1, 0, 0);
						meshPLY.geometry.attributes.color.setXYZ(myFaces[i].b, 1, 0, 0);
						meshPLY.geometry.attributes.color.setXYZ(myFaces[i].c, 1, 0, 0);
						meshPLY.geometry.attributes.color.needsUpdate = true;
					}
					console.log("Tracé terminé \nPoints qui ont été stockés:");
					console.log(myFaces[0]);
					for(i=0; i<myPoints.length; i++)
					{
						console.log("myPoints "+ i + ":"  + myPoints[i].x 
							+ " " + myPoints[i].y + " "+ myPoints[i].z);
					}
				}
				else 
				{
					for (var i=0; i<myFaces.length; i++)
					{
						console.log("hey");
						meshPLY.geometry.attributes.color.setXYZ(myFaces[i].a, 0, 1, 0);
						meshPLY.geometry.attributes.color.setXYZ(myFaces[i].b, 0, 1, 0);
						meshPLY.geometry.attributes.color.setXYZ(myFaces[i].c, 0, 1, 0);
						meshPLY.geometry.attributes.color.needsUpdate = true;
					}
					myBool = true;
					myPoints = new Array(); 
					myFaces = new Array();
					console.log("tracer le polygone");
				}
			}

////////////////////////////////////////////////////////////////////////

			function onMouseMove( event )
			{
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObject( meshPLY );


				if ( intersects.length > 0 ) 
				{
					//console.log(intersects[0]);
					//~ console.log("here");
					//~ console.log(intersects[0].face);
					var P = intersects[0].point;
					var F = intersects[0].face;
					if (myBool)
					{
						console.log("intersection : "+ P.x + " " + P.y + " "+ P.z);
						myPoints.push(P);
						myFaces.push(F);
					
						//~ meshPLY.geometry.attributes.color.setXYZ(F.a, 1, 0, 0);
						//~ meshPLY.geometry.attributes.color.setXYZ(F.b, 1, 0, 0);
						//~ meshPLY.geometry.attributes.color.setXYZ(F.c, 1, 0, 0);
						//~ meshPLY.geometry.attributes.color.needsUpdate = true;
					}
					
					//~ helper.position.set( 0, 0, 0 );
					//~ helper.lookAt( intersects[ 0 ].face.color );
					//~ helper.position.copy( intersects[ 0 ].point );
					
				}
			}

////////////////////////////////////////////////////////////////////////

			function onWindowResize() 
			{
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

////////////////////////////////////////////////////////////////////////

			function animate() 
			{
				requestAnimationFrame( animate );
				controls.update();

				render();
			}
			
////////////////////////////////////////////////////////////////////////

			function render() 
			{

				renderer.render( scene, camera );
				
				
		
			}

		</script>
	</body>
</html>
